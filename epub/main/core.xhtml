<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>zeptoscript Core Functionality</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="zeptoscript-core-functionality">
<h1>zeptoscript Core Functionality</h1>
<p>zeptoscript is a high-level, dynamically-typed language implemented on top of zeptoforth. It includes automatic memory management achieved through the use of a Cheney’s algorithm garbage collector.</p>
<p>zeptoscript has the following basic data types:</p>
<ul class="simple">
<li><p>Integrals, with subtypes being nulls, small integers (i.e. 31-bit), and big integers (i.e. 32-bit); note that <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code> are integrals, specifically -1 and 0.</p></li>
<li><p>Cell sequences</p></li>
<li><p>Cell slices</p></li>
<li><p>Byte sequences, with normal and constant subtypes</p></li>
<li><p>Byte slices</p></li>
<li><p>Execution tokens, with normal and closure subtypes</p></li>
</ul>
<p>All three subtypes of integrals are handled transparently to the user, and can only be told apart when the user applies the word <code class="docutils literal notranslate"><span class="pre">&gt;type</span></code> to them. However, in most cases the number 0 will be a null, all integers that can be unambiguously represented as two’s-complement numbers with 31 bits will be a small integer, and all integers that require a full 32 bits to be unambiguously represented will be a big integer. A key difference between nulls and small integers on one hand and bit integers on the other is that nulls and small integers are not allocated in the heap while big integers are; note that big integers require two cells to be stored for their heap allocation (in addition to any cells taken for references to them) while nulls and small integers only require one cell each.</p>
<p>Cell sequences, cell slices, non-constant byte sequences, and byte slices which have non-constant byte sequences as their backing store are mutable. Examples of words which may mutate these include <code class="docutils literal notranslate"><span class="pre">!+</span></code> (for cell sequences and slices), and <code class="docutils literal notranslate"><span class="pre">c!+</span></code>, <code class="docutils literal notranslate"><span class="pre">h!+</span></code>, and <code class="docutils literal notranslate"><span class="pre">w!+</span></code> (for byte sequences and slices). Other examples include <code class="docutils literal notranslate"><span class="pre">map!</span></code>, <code class="docutils literal notranslate"><span class="pre">mapi!</span></code>, <code class="docutils literal notranslate"><span class="pre">zip!</span></code>, <code class="docutils literal notranslate"><span class="pre">zip3!</span></code>, <code class="docutils literal notranslate"><span class="pre">reverse!</span></code>, and <code class="docutils literal notranslate"><span class="pre">sort!</span></code>, which transform sequences and slices in place. A general naming convention for mutating words is that they have <code class="docutils literal notranslate"><span class="pre">!</span></code> in their names.</p>
<p>The difference between sequences and slices is that sequences comprise a <em>backing store</em> whereas slices are references to an offset and length within a sequence. Consequently, mutating a slice mutates its underlying sequence and any other slices which share part of the same data within the same underlying sequence. In many cases they are more efficient to use rather than physically duplicating a sequence or a part of one; however, if one wants to create a separate sequence (which may be mutated without mutating the original sequence) from a sequence or slice one should use <code class="docutils literal notranslate"><span class="pre">duplicate</span></code> ( <em>seq</em> - <em>seq’</em> ), or another word that creates a new sequence from an existing one with a transformation, such as <code class="docutils literal notranslate"><span class="pre">map</span></code>, <code class="docutils literal notranslate"><span class="pre">mapi</span></code>, <code class="docutils literal notranslate"><span class="pre">filter</span></code>, <code class="docutils literal notranslate"><span class="pre">filteri</span></code>, <code class="docutils literal notranslate"><span class="pre">zip</span></code>, <code class="docutils literal notranslate"><span class="pre">zip3</span></code>, <code class="docutils literal notranslate"><span class="pre">reverse</span></code>, or <code class="docutils literal notranslate"><span class="pre">sort</span></code>.</p>
<p>Many of the operations work on all of cell sequences, cell slices, byte sequences (both normal and constant), and byte slices. However, there are exceptions; e.g. <code class="docutils literal notranslate"><span class="pre">&#64;+</span></code>, <code class="docutils literal notranslate"><span class="pre">!+</span></code>, and <code class="docutils literal notranslate"><span class="pre">cells&gt;</span></code> are only for cell sequences and slices while <code class="docutils literal notranslate"><span class="pre">c&#64;+</span></code>, <code class="docutils literal notranslate"><span class="pre">c!+</span></code>, <code class="docutils literal notranslate"><span class="pre">h&#64;+</span></code>, <code class="docutils literal notranslate"><span class="pre">h!+</span></code>, <code class="docutils literal notranslate"><span class="pre">w&#64;+</span></code>, <code class="docutils literal notranslate"><span class="pre">w!+</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">type</span></code> are only for byte sequences and slices.</p>
<p>Execution tokens and closures are closely related. Both execution tokens and closures may be executed with the words <code class="docutils literal notranslate"><span class="pre">execute</span></code>, <code class="docutils literal notranslate"><span class="pre">?execute</span></code>, and <code class="docutils literal notranslate"><span class="pre">try</span></code>; however, only execution tokens may be used as exceptions with <code class="docutils literal notranslate"><span class="pre">?raise</span></code>. The words <code class="docutils literal notranslate"><span class="pre">;]</span></code>, <code class="docutils literal notranslate"><span class="pre">'</span></code>, and <code class="docutils literal notranslate"><span class="pre">[']</span></code> create execution tokens, which reference code outside the zeptoscript heap which may be executed. The word <code class="docutils literal notranslate"><span class="pre">bind</span></code> ( <em>xn</em> … <em>x0</em> <em>count</em> <em>xt</em> – <em>closure</em> ) takes an execution token <em>xt</em> and binds it to <em>count</em> values on the stack, producing a <em>closure</em>, which when executed will push values <em>xn</em> … <em>x0</em> onto the stack prior to executing <em>xt</em>. Both execution tokens and closures live on the heap. Note, though, that there may be cases where one may need to convert between execution tokens and integrals referencing the addresses of their underlying code; these conversions are achieved with <code class="docutils literal notranslate"><span class="pre">unsafe::integral&gt;xt</span></code> ( <em>integral</em> – <em>xt</em> ) and <code class="docutils literal notranslate"><span class="pre">unsafe::xt&gt;integral</span></code> ( <em>xt</em> – <em>integral</em> ). These conversions may not be made with closures.</p>
<p>zeptoscript does not make use of standard Forth <code class="docutils literal notranslate"><span class="pre">variable</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code>; while these are retained for legacy reasons they may only be used with extreme caution and are best avoided when possible. Rather, zeptoscript provides <code class="docutils literal notranslate"><span class="pre">global</span></code> ( “name” – ); unlike <code class="docutils literal notranslate"><span class="pre">variable</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code>, the garbage collector is aware of <code class="docutils literal notranslate"><span class="pre">global</span></code>s, so potentially garbage-collected values can be stored in them, whereas it is very much unsafe to put allocated values, including big integers, in <code class="docutils literal notranslate"><span class="pre">variable</span></code>s or <code class="docutils literal notranslate"><span class="pre">value</span></code>s. Note that globals may be declared either when compiling to RAM or when compiling to flash.</p>
<p>Take the following for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">global</span> <span class="n">foo</span>
</pre></div>
</div>
<p>This creates the following words:</p>
<ul class="simple">
<li><p>A getter word <code class="docutils literal notranslate"><span class="pre">foo&#64;</span></code> ( – <em>foo</em> )</p></li>
<li><p>A setter word <code class="docutils literal notranslate"><span class="pre">foo!</span></code> ( <em>foo</em> – )</p></li>
</ul>
<p>One feature of zeptoscript is <em>records</em>. <em>Records</em> are essentially syntactic sugar on top of cell sequences which provides accessor words for constructing, setting, and accessing cell sequences and their elements. In many cases it leads to more readable code than using <code class="docutils literal notranslate"><span class="pre">&gt;cells</span></code>, <code class="docutils literal notranslate"><span class="pre">cells&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;+</span></code>, and <code class="docutils literal notranslate"><span class="pre">!+</span></code> directly when one is using a cell sequence for purposes other than acting as a vector/array.</p>
<p>Take the following for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">begin</span><span class="o">-</span><span class="n">record</span> <span class="n">foo</span>
  <span class="n">item</span><span class="p">:</span> <span class="n">foo</span><span class="o">-</span><span class="n">x</span>
  <span class="n">item</span><span class="p">:</span> <span class="n">foo</span><span class="o">-</span><span class="n">y</span>
  <span class="n">item</span><span class="p">:</span> <span class="n">foo</span><span class="o">-</span><span class="n">z</span>
<span class="n">end</span><span class="o">-</span><span class="n">record</span>
</pre></div>
</div>
<p>This creates the following words:</p>
<ul class="simple">
<li><p>A constructor word <code class="docutils literal notranslate"><span class="pre">make-foo</span></code> ( – <em>foo</em> ) for creating an empty (i.e. all null) record with three elements.</p></li>
<li><p>A constructor word <code class="docutils literal notranslate"><span class="pre">&gt;foo</span></code> ( <em>foo-x</em> <em>foo-y</em> <em>foo-z</em> – <em>foo</em> ) for creating a record containing the specified elements popped off the stack</p></li>
<li><p>An exploding word <code class="docutils literal notranslate"><span class="pre">foo&gt;</span></code> ( <em>foo</em> – <em>foo-x</em> <em>foo-y</em> <em>foo-z</em> ) which takes a record <em>foo</em> and pushes its elements onto the stack.</p></li>
<li><p>A word <code class="docutils literal notranslate"><span class="pre">foo-size</span></code> ( – size ) which pushes the size in elements of a <em>foo</em> record, in this case three.</p></li>
<li><p>The words <code class="docutils literal notranslate"><span class="pre">foo-x&#64;</span></code> ( <em>foo</em> – <em>foo-x</em> ), <code class="docutils literal notranslate"><span class="pre">foo-y&#64;</span></code> ( <em>foo</em> – <em>foo-y</em> ), and <code class="docutils literal notranslate"><span class="pre">foo-z&#64;</span></code> ( <em>foo</em> – <em>foo-z</em> ) for fetching named elements of <em>foo</em>.</p></li>
<li><p>The words <code class="docutils literal notranslate"><span class="pre">foo-x!</span></code> ( <em>foo-x</em> <em>foo</em> – ), <code class="docutils literal notranslate"><span class="pre">foo-y!</span></code> ( <em>foo-y</em> <em>foo</em> – ), and <code class="docutils literal notranslate"><span class="pre">foo-z!</span></code> ( <em>foo-z</em> <em>foo</em> – ) for setting named elements of <em>foo</em>.</p></li>
</ul>
<p>Before zeptoscript can be used it must be initialized with <code class="docutils literal notranslate"><span class="pre">zscript::init-zscript</span></code> ( <em>compile-size</em> <em>runtime-size</em> – ). If this is done during compilation to flash <em>compile-size</em> is used for the heap size, otherwise <em>runtime-size</em> is used. Also, if this is done during compilation to flash an <code class="docutils literal notranslate"><span class="pre">init</span></code> routine is compiled to flash which initializes the heap to <em>runtime-size</em> next time the system is booted. Note that <em>compile-size</em> and <em>runtime-size</em> are rounded up to the nearest full multiple of eight bytes. All code to be compiled which is not zeptoscript code must be compiled before this point, as <code class="docutils literal notranslate"><span class="pre">zscript::init-zscript</span></code> overrides the numeric parser and thus will break non-zeptoscript code. Also, all code to be compiled which is zeptoscript code must be compiled after this point, as it will break otherwise (as compiling zeptoscript code outside of <code class="docutils literal notranslate"><span class="pre">src/common/core.fs</span></code> requires an initialized zeptoscript heap and numeric parser).</p>
<p>zeptoscript code may only execute in one task, because the zeptoscript garbage collector is only aware of the current task, and the synchronization necessary to achieve execution across tasks would prove problematic. However, for asynchronous programming, an <em>action scheduler</em> mechanism is provided by <code class="docutils literal notranslate"><span class="pre">src/common/action.fs</span></code>. This is similar to the zeptoforth action scheduler, but has a few minor differences (e.g. data transferred between actions is not copied aside from the copying of integral messages and references to allocated messages). The action scheduler is “stackless” in that every action shares the same underlying data and return stacks, and storing state information between states is accomplished through providing closures for each state, and in said closures referencing outside data.</p>
<p>S15.16 fixed-point numerics are provided by <code class="docutils literal notranslate"><span class="pre">src/common/fixed32.fs</span></code>. These fixed-point numbers are cell-sized so they fit in the space of normal integrals. Note that operations for addition, subtraction, and negation are not included in <code class="docutils literal notranslate"><span class="pre">src/common/fixed32.fs</span></code>. This is because normal integral <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, and <code class="docutils literal notranslate"><span class="pre">negate</span></code> fits these roles. Note that loading <code class="docutils literal notranslate"><span class="pre">src/common/fixed32.fs</span></code> overrides the numeric parser to enable parsing S15.16 literals, which have the form <code class="docutils literal notranslate"><span class="pre">x;y</span></code> where <code class="docutils literal notranslate"><span class="pre">;</span></code> is the decimal point.</p>
<section id="words">
<h2>Words</h2>
<section id="null-type">
<h3><code class="docutils literal notranslate"><span class="pre">null-type</span></code></h3>
<p>( – type )</p>
<p>The null type.</p>
</section>
<section id="int-type">
<h3><code class="docutils literal notranslate"><span class="pre">int-type</span></code></h3>
<p>( – type )</p>
<p>The small integer type.</p>
</section>
<section id="bytes-type">
<h3><code class="docutils literal notranslate"><span class="pre">bytes-type</span></code></h3>
<p>( – type )</p>
<p>The non-constant byte sequence type.</p>
</section>
<section id="word-type">
<h3><code class="docutils literal notranslate"><span class="pre">word-type</span></code></h3>
<p>( – type )</p>
<p>The big integer type.</p>
</section>
<section id="id1">
<h3><code class="docutils literal notranslate"><span class="pre">2word-type</span></code></h3>
<p>( – type )</p>
<p>The double-cell type (for future use).</p>
</section>
<section id="const-bytes-type">
<h3><code class="docutils literal notranslate"><span class="pre">const-bytes-type</span></code></h3>
<p>( – type )</p>
<p>The constant byte sequence type.</p>
</section>
<section id="xt-type">
<h3><code class="docutils literal notranslate"><span class="pre">xt-type</span></code></h3>
<p>( – type )</p>
<p>The execution token type.</p>
</section>
<section id="tagged-type">
<h3><code class="docutils literal notranslate"><span class="pre">tagged-type</span></code></h3>
<p>( – type )</p>
<p>A type for auxiliary types, such as words.</p>
</section>
<section id="cells-type">
<h3><code class="docutils literal notranslate"><span class="pre">cells-type</span></code></h3>
<p>( – type )</p>
<p>The cell sequence type.</p>
</section>
<section id="closure-type">
<h3><code class="docutils literal notranslate"><span class="pre">closure-type</span></code></h3>
<p>( – type )</p>
<p>The closure type.</p>
</section>
<section id="slice-type">
<h3><code class="docutils literal notranslate"><span class="pre">slice-type</span></code></h3>
<p>( – type )</p>
<p>The slice type; note that this encompasses slices of cell sequences, non-constant byte sequences, and constant byte sequences.</p>
</section>
<section id="raw-lit">
<h3><code class="docutils literal notranslate"><span class="pre">raw-lit,</span></code></h3>
<p>( x – )</p>
<p>Compile an integral value as a raw literal which, when executed, will push its value as a zeptoforth integral value rather than a zeptoscript integral value.</p>
</section>
<section id="lit">
<h3><code class="docutils literal notranslate"><span class="pre">lit,</span></code></h3>
<p>( x – )</p>
<p>Compile an integral value as a literal which, when executed, will push its value as a zeptoscript integral value.</p>
</section>
<section id="addr-len-const-bytes">
<h3><code class="docutils literal notranslate"><span class="pre">addr-len&gt;const-bytes</span></code></h3>
<p>( c-addr len – const-bytes )</p>
<p>Create a constant byte sequence from a non-volatile address and length; this is intended for string literals compiled into code.</p>
</section>
<section id="addr-len-bytes">
<h3><code class="docutils literal notranslate"><span class="pre">addr-len&gt;bytes</span></code></h3>
<p>( c-addr len – bytes )</p>
<p>Create a non-constant byte sequence from a potentially-volatile address and length; when creating byte sequences from raw data which is not compiled into code this is normally what you would want.</p>
</section>
<section id="raw">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;raw</span></code></h3>
<p>( x – x’ )</p>
<p>Get the raw backing store of a cell sequence, byte sequence, or slice value. The primary purpose of this is for converting slices into their underlying cell or byte sequences.</p>
</section>
<section id="raw-offset">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;raw-offset</span></code></h3>
<p>( x – offset )</p>
<p>Get the raw offset of a cell sequence, byte sequence, or slice value. The primary purpose of this is for determining where a slice points into its underlying cell or byte sequence.</p>
</section>
<section id="len">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;len</span></code></h3>
<p>( x – len )</p>
<p>Get the length of a cell sequence, byte sequence, or slice in entries or bytes.</p>
</section>
<section id="pair">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;pair</span></code></h3>
<p>( x0 x1 – pair )</p>
<p>Create a two-element cell sequence from a pair of values.</p>
</section>
<section id="id2">
<h3><code class="docutils literal notranslate"><span class="pre">pair&gt;</span></code></h3>
<p>( pair – x0 x1 )</p>
<p>Explode a two-element cell sequence or slice into a pair of values.</p>
</section>
<section id="triple">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;triple</span></code></h3>
<p>( x0 x1 x2 – triple )</p>
<p>Create a three-element cell sequence from three values.</p>
</section>
<section id="id3">
<h3><code class="docutils literal notranslate"><span class="pre">triple&gt;</span></code></h3>
<p>( triple – x0 x1 x2 )</p>
<p>Explode a three-element cell sequence or slice into three values.</p>
</section>
<section id="make-cells">
<h3><code class="docutils literal notranslate"><span class="pre">make-cells</span></code></h3>
<p>( count – cells )</p>
<p>Create a cell sequence with the specified element count that is initialized to null.</p>
</section>
<section id="make-bytes">
<h3><code class="docutils literal notranslate"><span class="pre">make-bytes</span></code></h3>
<p>( count – bytes )</p>
<p>Create a byte sequence with the specified byte count that is initialized to null.</p>
</section>
<section id="cells">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;cells</span></code></h3>
<p>( xn … x0 count – cells )</p>
<p>Create a cell sequence with <em>count</em> elements taken off the stack.</p>
</section>
<section id="bytes">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;bytes</span></code></h3>
<p>( cn … c0 count – bytes )</p>
<p>Create a byte sequence with <em>count</em> bytes taken off the stack.</p>
</section>
<section id="id4">
<h3><code class="docutils literal notranslate"><span class="pre">cells&gt;</span></code></h3>
<p>( cells – xn … x0 count )</p>
<p>Explode a cell sequence or slice into elements and a count on the stack.</p>
</section>
<section id="id5">
<h3><code class="docutils literal notranslate"><span class="pre">bytes&gt;</span></code></h3>
<p>( bytes – cn … c0 count )</p>
<p>Explode a byte sequence or slice into bytes and a count on the stack.</p>
</section>
<section id="cells-no-count">
<h3><code class="docutils literal notranslate"><span class="pre">cells-no-count&gt;</span></code></h3>
<p>( cells – xn … x0 )</p>
<p>Explode a cell sequence or slice into elements on the stack.</p>
</section>
<section id="bytes-no-count">
<h3><code class="docutils literal notranslate"><span class="pre">bytes-no-count&gt;</span></code></h3>
<p>( bytes – cn … c0 )</p>
<p>Explode a byte sequence or slice into bytes on the stack.</p>
</section>
<section id="id6">
<h3><code class="docutils literal notranslate"><span class="pre">&#64;+</span></code></h3>
<p>( index cells – x )</p>
<p>Get the element at <em>index</em>, indexed from zero, of a cell sequence or slice.</p>
</section>
<section id="id7">
<h3><code class="docutils literal notranslate"><span class="pre">!+</span></code></h3>
<p>( x index cells – )</p>
<p>Set the elememt at <em>index</em>, indexed from zero, of a cell sequence or slice.</p>
</section>
<section id="w">
<h3><code class="docutils literal notranslate"><span class="pre">w&#64;+</span></code></h3>
<p>( index bytes – x )</p>
<p>Get the cell at <em>index</em>, indexed from zero and word-aligned, of a byte sequence or slice.</p>
</section>
<section id="id8">
<h3><code class="docutils literal notranslate"><span class="pre">w!+</span></code></h3>
<p>( x index bytes – )</p>
<p>Set the cell at <em>index</em>, indexed from zero and word-aligned, of a non-constant byte sequence or slice.</p>
</section>
<section id="h">
<h3><code class="docutils literal notranslate"><span class="pre">h&#64;+</span></code></h3>
<p>( index bytes – h )</p>
<p>Get the halfword at <em>index</em>, indexed from zero and halfword-aligned, of a byte sequence or slice.</p>
</section>
<section id="id9">
<h3><code class="docutils literal notranslate"><span class="pre">h!+</span></code></h3>
<p>( h index bytes – )</p>
<p>Set the halfword at <em>index</em>, indexed from zero and halfword-aligned, of a non-constant byte sequence or slice.</p>
</section>
<section id="c">
<h3><code class="docutils literal notranslate"><span class="pre">c&#64;+</span></code></h3>
<p>( index bytes – c )</p>
<p>Get the byte at <em>index</em>, indexed from zero, of a byte sequence or slice.</p>
</section>
<section id="id10">
<h3><code class="docutils literal notranslate"><span class="pre">c!+</span></code></h3>
<p>( c index bytes – )</p>
<p>Set the byte at <em>index</em>, indexed from zero, of a non-constant byte sequence or slice.</p>
</section>
<section id="x">
<h3><code class="docutils literal notranslate"><span class="pre">x&#64;+</span></code></h3>
<p>( index cells|bytes – x )</p>
<p>Get the element or byte at <em>index</em>, indexed from zero, of a cell or byte sequence or slice.</p>
</section>
<section id="id11">
<h3><code class="docutils literal notranslate"><span class="pre">x!+</span></code></h3>
<p>( x index cells|bytes – )</p>
<p>Set the elememt or byte at <em>index</em>, indexed from zero, of a non-constant cell or byte sequence or slice.</p>
</section>
<section id="id12">
<h3><code class="docutils literal notranslate"><span class="pre">cells?</span></code></h3>
<p>( x – cells? )</p>
<p>Get whether a value is a cell sequence or slice.</p>
</section>
<section id="id13">
<h3><code class="docutils literal notranslate"><span class="pre">bytes?</span></code></h3>
<p>( x – bytes? )</p>
<p>Get whether a value is a byte sequence or slice.</p>
</section>
<section id="init-zscript">
<h3><code class="docutils literal notranslate"><span class="pre">init-zscript</span></code></h3>
<p>( compile-size runtime-size – )</p>
<p>Initialize zeptoscript. All non-zeptoscript code must be compiled before this word is called, and all zeptoscript code must be compiled after this word is called. If called during compilation to flash, a call to this word will be compiled into the initialization process on bootup, so zeptoscript will automatically be initialized after the previous definition of <code class="docutils literal notranslate"><span class="pre">init</span></code> (or declaration of an <code class="docutils literal notranslate"><span class="pre">initializer</span></code>) and before any subsequent definitions of <code class="docutils literal notranslate"><span class="pre">init</span></code> (or declarations of <code class="docutils literal notranslate"><span class="pre">initializer</span></code>). Note that when compiling to flash the zeptoscript heap size will be initialized to <em>compile-size</em>, but when compiling to RAM or on any subsequent boot the zeptoscript heap size will be initialized to <em>runtime-size</em>. Note that the heap size is rounded up to the nearest eight bytes.</p>
</section>
<section id="copy">
<h3><code class="docutils literal notranslate"><span class="pre">copy</span></code></h3>
<p>( value0 offset0 value1 offset1 count – )</p>
<p>Do a shallow copy of <em>count</em> elements or bytes from one cell or byte sequence or slice to another, starting at <em>offset0</em> of <em>value0</em> to <em>offset1</em> of <em>value1</em>. All offsets are indexed from zero. <em>value0</em> and <em>value1</em> must both be either cell sequences or slices or byte sequences or slices; copying between cell sequences or slices and byte sequences or slices is not permitted. Also note that <em>value1</em> cannot be a constant byte sequence or slice.</p>
</section>
<section id="s">
<h3><code class="docutils literal notranslate"><span class="pre">s&quot;</span></code></h3>
<p>( “string” – bytes )</p>
<p>Create a string literal as a byte sequence; note that if compiled the resulting byte sequence is constant, whereas if immediate the resulting byte sequence is non-constant.</p>
</section>
<section id="id14">
<h3><code class="docutils literal notranslate"><span class="pre">s\&quot;</span></code></h3>
<p>Create a string literal with escapes as a byte sequence; note that if compiled the resulting byte sequence is constant, whereas if immediate the resulting byte sequence is non-constant.</p>
</section>
<section id="id15">
<h3><code class="docutils literal notranslate"><span class="pre">+</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Add two integers.</p>
</section>
<section id="id16">
<h3><code class="docutils literal notranslate"><span class="pre">1+</span></code></h3>
<p>( x0 – x1 )</p>
<p>Add one to an integer.</p>
</section>
<section id="cell">
<h3><code class="docutils literal notranslate"><span class="pre">cell+</span></code></h3>
<p>( x0 – x1 )</p>
<p>Add a cell, i.e. four, to an integer.</p>
</section>
<section id="id17">
<h3><code class="docutils literal notranslate"><span class="pre">-</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Subtract two integers.</p>
</section>
<section id="id18">
<h3><code class="docutils literal notranslate"><span class="pre">1-</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Subtract one from an integer.</p>
</section>
<section id="id19">
<h3><code class="docutils literal notranslate"><span class="pre">*</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Multiply two integers.</p>
</section>
<section id="id20">
<h3><code class="docutils literal notranslate"><span class="pre">2*</span></code></h3>
<p>( x0 – x1 )</p>
<p>Multiply an integer by two.</p>
</section>
<section id="id21">
<h3><code class="docutils literal notranslate"><span class="pre">4*</span></code></h3>
<p>( x0 – x1 )</p>
<p>Multiply an integer by four.</p>
</section>
<section id="id22">
<h3><code class="docutils literal notranslate"><span class="pre">cells</span></code></h3>
<p>( x0 – x1 )</p>
<p>Multiply an integer by a cell.</p>
</section>
<section id="id23">
<h3><code class="docutils literal notranslate"><span class="pre">/</span></code></h3>
<p>( n0 n1 – n2 )</p>
<p>Divide two signed integers.</p>
</section>
<section id="id24">
<h3><code class="docutils literal notranslate"><span class="pre">2/</span></code></h3>
<p>( n0 – n1 )</p>
<p>Divide a signed integer by two.</p>
</section>
<section id="id25">
<h3><code class="docutils literal notranslate"><span class="pre">4/</span></code></h3>
<p>( n0 – n1 )</p>
<p>Divide a signed integer by four.</p>
</section>
<section id="u">
<h3><code class="docutils literal notranslate"><span class="pre">u/</span></code></h3>
<p>( u0 u1 – u2 )</p>
<p>Divide two unsigned integers.</p>
</section>
<section id="mod">
<h3><code class="docutils literal notranslate"><span class="pre">mod</span></code></h3>
<p>( n0 n1 – n2 )</p>
<p>Get the modulus of two signed integers.</p>
</section>
<section id="umod">
<h3><code class="docutils literal notranslate"><span class="pre">umod</span></code></h3>
<p>( u0 u1 – u2 )</p>
<p>Get the modulus of two unsigned integers.</p>
</section>
<section id="negate">
<h3><code class="docutils literal notranslate"><span class="pre">negate</span></code></h3>
<p>( n0 – n1 )</p>
<p>Negate an integer.</p>
</section>
<section id="or">
<h3><code class="docutils literal notranslate"><span class="pre">or</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Or two integers.</p>
</section>
<section id="and">
<h3><code class="docutils literal notranslate"><span class="pre">and</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>And two integers.</p>
</section>
<section id="xor">
<h3><code class="docutils literal notranslate"><span class="pre">xor</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Exclusive-or two integers.</p>
</section>
<section id="bic">
<h3><code class="docutils literal notranslate"><span class="pre">bic</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Clear bits in an integer.</p>
</section>
<section id="not">
<h3><code class="docutils literal notranslate"><span class="pre">not</span></code></h3>
<p>( x0 – x1 )</p>
<p>Not an integer.</p>
</section>
<section id="invert">
<h3><code class="docutils literal notranslate"><span class="pre">invert</span></code></h3>
<p>( x0 – x1 )</p>
<p>Invert an integer.</p>
</section>
<section id="lshift">
<h3><code class="docutils literal notranslate"><span class="pre">lshift</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Left shift an integer.</p>
</section>
<section id="rshift">
<h3><code class="docutils literal notranslate"><span class="pre">rshift</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Logical right shift an integer.</p>
</section>
<section id="arshift">
<h3><code class="docutils literal notranslate"><span class="pre">arshift</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Arithmetic right shift an integer.</p>
</section>
<section id="align">
<h3><code class="docutils literal notranslate"><span class="pre">align</span></code></h3>
<p>( x0 x1 – x2 )</p>
<p>Align a value to a power of two.</p>
</section>
<section id="id26">
<h3><code class="docutils literal notranslate"><span class="pre">=</span></code></h3>
<p>( x0 x1 – flag )</p>
<p>Get whether two values are equal. Integral values are compared for their values, even in the case of big integers. Execution tokens are compared for their underlying code addresses. All other values are compared for their addresses in memory.</p>
</section>
<section id="id27">
<h3><code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code></h3>
<p>( x0 x1 – flag )</p>
<p>Get whether two values are unequal. Integral values are compared for their values, even in the case of big integers. Execution tokens are compared for their underlying code addresses. All other values are compared for their addresses in memory.</p>
</section>
<section id="id28">
<h3><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></h3>
<p>( n0 n1 – flag )</p>
<p>Signed less than.</p>
</section>
<section id="id29">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></h3>
<p>( n0 n1 – flag )</p>
<p>Signed greater than.</p>
</section>
<section id="id30">
<h3><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></h3>
<p>( n0 n1 – flag )</p>
<p>Signed less than or equal.</p>
</section>
<section id="id31">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></h3>
<p>( n0 n1 – flag )</p>
<p>Signed greater than or equal.</p>
</section>
<section id="id32">
<h3><code class="docutils literal notranslate"><span class="pre">u&lt;</span></code></h3>
<p>( u0 u1 – flag )</p>
<p>Unsigned less than.</p>
</section>
<section id="id33">
<h3><code class="docutils literal notranslate"><span class="pre">u&gt;</span></code></h3>
<p>( u0 u1 – flag )</p>
<p>Unsigned greater than.</p>
</section>
<section id="id34">
<h3><code class="docutils literal notranslate"><span class="pre">u&lt;=</span></code></h3>
<p>( u0 u1 – flag )</p>
<p>Unsigned less than or equal.</p>
</section>
<section id="id35">
<h3><code class="docutils literal notranslate"><span class="pre">u&gt;=</span></code></h3>
<p>( u0 u1 – flag )</p>
<p>Unsigned greater than or equal.</p>
</section>
<section id="id36">
<h3><code class="docutils literal notranslate"><span class="pre">u&lt;</span></code></h3>
<p>( u0 u1 – flag )</p>
<p>Unsigned less than.</p>
</section>
<section id="id37">
<h3><code class="docutils literal notranslate"><span class="pre">u&gt;</span></code></h3>
<p>( u0 u1 – flag )</p>
<p>Unsigned greater than.</p>
</section>
<section id="id38">
<h3><code class="docutils literal notranslate"><span class="pre">u&lt;=</span></code></h3>
<p>( u0 u1 – flag )</p>
<p>Unsigned less than or equal.</p>
</section>
<section id="id39">
<h3><code class="docutils literal notranslate"><span class="pre">u&gt;=</span></code></h3>
<p>( u0 u1 – flag )</p>
<p>Unsigned greater than or equal.</p>
</section>
<section id="id40">
<h3><code class="docutils literal notranslate"><span class="pre">0=</span></code></h3>
<p>( x – flag )</p>
<p>Equal to zero; note that for non-integral values <code class="docutils literal notranslate"><span class="pre">false</span></code> is returned.</p>
</section>
<section id="id41">
<h3><code class="docutils literal notranslate"><span class="pre">0&lt;&gt;</span></code></h3>
<p>( x – flag )</p>
<p>Not equal to zero; note that for non-integral values <code class="docutils literal notranslate"><span class="pre">true</span></code> is returned.</p>
</section>
<section id="id42">
<h3><code class="docutils literal notranslate"><span class="pre">0&lt;</span></code></h3>
<p>( n – flag )</p>
<p>Less than zero.</p>
</section>
<section id="id43">
<h3><code class="docutils literal notranslate"><span class="pre">0&gt;</span></code></h3>
<p>( n – flag )</p>
<p>Greater than zero.</p>
</section>
<section id="id44">
<h3><code class="docutils literal notranslate"><span class="pre">0&lt;=</span></code></h3>
<p>( n – flag )</p>
<p>Less than or equal to zero.</p>
</section>
<section id="id45">
<h3><code class="docutils literal notranslate"><span class="pre">0&gt;=</span></code></h3>
<p>( n – flag )</p>
<p>Greater than or equal to zero.</p>
</section>
<section id="min">
<h3><code class="docutils literal notranslate"><span class="pre">min</span></code></h3>
<p>( n0 n1 – n2 )</p>
<p>Get the minimum of two numbers.</p>
</section>
<section id="max">
<h3><code class="docutils literal notranslate"><span class="pre">max</span></code></h3>
<p>( n0 n1 – n2 )</p>
<p>Get the maximum of two numbers.</p>
</section>
<section id="id46">
<h3><code class="docutils literal notranslate"><span class="pre">cell</span></code></h3>
<p>( – u )</p>
<p>The size of a cell, i.e. four.</p>
</section>
<section id="if">
<h3><code class="docutils literal notranslate"><span class="pre">if</span></code></h3>
<p>( x – )</p>
<p>If conditional; note that non-integral values are treated as true.</p>
</section>
<section id="while">
<h3><code class="docutils literal notranslate"><span class="pre">while</span></code></h3>
<p>( x – )</p>
<p>While conditional; note that non-integral values are treated as true.</p>
</section>
<section id="until">
<h3><code class="docutils literal notranslate"><span class="pre">until</span></code></h3>
<p>( x – )</p>
<p>Until conditional; note that non-integral values are treated as true.</p>
</section>
<section id="do">
<h3><code class="docutils literal notranslate"><span class="pre">?do</span></code></h3>
<p>( end start – )</p>
<p>Start <code class="docutils literal notranslate"><span class="pre">do</span></code> loop; note that this is redefined because of the chance that two vales may be equal but have different types.</p>
</section>
<section id="loop">
<h3><code class="docutils literal notranslate"><span class="pre">loop</span></code></h3>
<p>( – )</p>
<p>Close a <code class="docutils literal notranslate"><span class="pre">do</span></code> loop.</p>
</section>
<section id="id47">
<h3><code class="docutils literal notranslate"><span class="pre">+loop</span></code></h3>
<p>( increment – )</p>
<p>Close a <code class="docutils literal notranslate"><span class="pre">do</span></code> loop with an increment.</p>
</section>
<section id="case">
<h3><code class="docutils literal notranslate"><span class="pre">case</span></code></h3>
<p>( x – )</p>
<p>Start a <code class="docutils literal notranslate"><span class="pre">case</span></code> block.</p>
</section>
<section id="of">
<h3><code class="docutils literal notranslate"><span class="pre">of</span></code></h3>
<p>( x – )</p>
<p>Start an <code class="docutils literal notranslate"><span class="pre">of</span></code> block.</p>
</section>
<section id="id48">
<h3><code class="docutils literal notranslate"><span class="pre">.</span></code></h3>
<p>( n – )</p>
<p>Print a signed integer with a following space.</p>
</section>
<section id="id49">
<h3><code class="docutils literal notranslate"><span class="pre">u.</span></code></h3>
<p>( u – )</p>
<p>Print an unsigned integer with a following space.</p>
</section>
<section id="id50">
<h3><code class="docutils literal notranslate"><span class="pre">(.)</span></code></h3>
<p>( n – )</p>
<p>Print a signed integer without a following space.</p>
</section>
<section id="id51">
<h3><code class="docutils literal notranslate"><span class="pre">(u.)</span></code></h3>
<p>( u – )</p>
<p>Print an unsigned integer without a following space.</p>
</section>
<section id="emit">
<h3><code class="docutils literal notranslate"><span class="pre">emit</span></code></h3>
<p>( c – )</p>
<p>Print a character.</p>
</section>
<section id="h-1">
<h3><code class="docutils literal notranslate"><span class="pre">h.1</span></code></h3>
<p>( x – )</p>
<p>Print the lowest four bits of an unsigned integer as one hexadecimal digit.</p>
</section>
<section id="h-2">
<h3><code class="docutils literal notranslate"><span class="pre">h.2</span></code></h3>
<p>( x – )</p>
<p>Print the lowest eight bits of an unsigned integer as two hexadecimal digits.</p>
</section>
<section id="h-4">
<h3><code class="docutils literal notranslate"><span class="pre">h.4</span></code></h3>
<p>( x – )</p>
<p>Print the lowest sixteen bits of an unsigned integer as four hexadecimal digits.</p>
</section>
<section id="h-8">
<h3><code class="docutils literal notranslate"><span class="pre">h.8</span></code></h3>
<p>( x – )</p>
<p>Print an unsigned integer as eight hexadecimal digits.</p>
</section>
<section id="h-16">
<h3><code class="docutils literal notranslate"><span class="pre">h.16</span></code></h3>
<p>( d – )</p>
<p>Print a double cell unsigned integer as sixteen hexadecimal digits.</p>
</section>
<section id="spaces">
<h3><code class="docutils literal notranslate"><span class="pre">spaces</span></code></h3>
<p>( x – )</p>
<p>Print <em>x</em> spaces.</p>
</section>
<section id="slice">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;slice</span></code></h3>
<p>( offset length seq – slice )</p>
<p>Get an arbitrary slice of a sequence or slice of <em>length</em> starting at <em>offset</em>.</p>
</section>
<section id="truncate-start">
<h3><code class="docutils literal notranslate"><span class="pre">truncate-start</span></code></h3>
<p>( count seq – slice )</p>
<p>Get a slice of a sequence or slice truncating <em>count</em> elements or bytes from the start.</p>
</section>
<section id="truncate-end">
<h3><code class="docutils literal notranslate"><span class="pre">truncate-end</span></code></h3>
<p>( count seq – slice )</p>
<p>Get a slice of a sequence or slice truncating <em>count</em> elements or bytes from the end.</p>
</section>
<section id="type">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;type</span></code></h3>
<p>( x – type )</p>
<p>Get the type of a value.</p>
</section>
<section id="integral">
<h3><code class="docutils literal notranslate"><span class="pre">integral?</span></code></h3>
<p>( x – integral? )</p>
<p>Get whether a value is integral.</p>
</section>
<section id="small-int">
<h3><code class="docutils literal notranslate"><span class="pre">small-int?</span></code></h3>
<p>( x – small-int? )</p>
<p>Get whether a value is a small integer or null.</p>
</section>
<section id="token">
<h3><code class="docutils literal notranslate"><span class="pre">token</span></code></h3>
<p>( runtime: “name” – seq | 0 )</p>
<p>Parse a token and return it as a byte sequence, or return 0 if no token could be parsed.</p>
</section>
<section id="token-word">
<h3><code class="docutils literal notranslate"><span class="pre">token-word</span></code></h3>
<p>( runtime: “name” – word )</p>
<p>Parse a token and get the corresponding word; note that an exception will be raised if there is no token or the word cannot be found.</p>
</section>
<section id="word-xt">
<h3><code class="docutils literal notranslate"><span class="pre">word&gt;xt</span></code></h3>
<p>( word – xt )</p>
<p>Get an execution token corresponding to a word.</p>
</section>
<section id="id52">
<h3><code class="docutils literal notranslate"><span class="pre">;]</span></code></h3>
<p>( – xt )</p>
<p>End a quotation (also known as a lambda) and, if compiling, compile pushing the execution token, or otherwise immediately pushing the execution token.</p>
</section>
<section id="execute">
<h3><code class="docutils literal notranslate"><span class="pre">execute</span></code></h3>
<p>( xt | closure – )</p>
<p>Execute an execution token or closure. If a closure is executed, push the bound values onto the stack prior to executing the underlying execution token.</p>
</section>
<section id="try">
<h3><code class="docutils literal notranslate"><span class="pre">try</span></code></h3>
<p>( xt | closure – exception | 0 )</p>
<p>Execute an execution token or closure like <code class="docutils literal notranslate"><span class="pre">execute</span></code>, but catching any exceptions that are raised. If an exception is raised it is returned, otherwise 0 is returned.</p>
</section>
<section id="id53">
<h3><code class="docutils literal notranslate"><span class="pre">?execute</span></code></h3>
<p>( xt | closure | 0 – )</p>
<p>If a non-zero value is provided it is executed like with <code class="docutils literal notranslate"><span class="pre">execute</span></code>, otherwise it is ignored.</p>
</section>
<section id="id54">
<h3><code class="docutils literal notranslate"><span class="pre">type</span></code></h3>
<p>( seq – )</p>
<p>Type a string.</p>
</section>
<section id="id55">
<h3><code class="docutils literal notranslate"><span class="pre">'</span></code></h3>
<p>( “name” – xt )</p>
<p>Get an xt at interpretation-time.</p>
</section>
<section id="id56">
<h3><code class="docutils literal notranslate"><span class="pre">[']</span></code></h3>
<p>( ‘name” – xt )</p>
<p>Get an xt at compile-time.</p>
</section>
<section id="raise">
<h3><code class="docutils literal notranslate"><span class="pre">?raise</span></code></h3>
<p>( xt – )</p>
<p>Raise an exception.</p>
</section>
<section id="averts">
<h3><code class="docutils literal notranslate"><span class="pre">averts</span></code></h3>
<p>( f “name” – )</p>
<p>Assert that a value is true, otherwise raise a specified exception.</p>
</section>
<section id="triggers">
<h3><code class="docutils literal notranslate"><span class="pre">triggers</span></code></h3>
<p>( f “name” – )</p>
<p>Assert that a value is false, otherwise raise a specified exception.</p>
</section>
<section id="id57">
<h3><code class="docutils literal notranslate"><span class="pre">raise</span></code></h3>
<p>( “name” – )</p>
<p>Always raise an exception; this is needed due to issues with compiling code.</p>
</section>
<section id="start-compile">
<h3><code class="docutils literal notranslate"><span class="pre">start-compile</span></code></h3>
<p>( seq – )</p>
<p>Start compiling a word with a name.</p>
</section>
<section id="end-compile">
<h3><code class="docutils literal notranslate"><span class="pre">end-compile,</span></code></h3>
<p>( – )</p>
<p>End compiling, exported to match start-compile.</p>
</section>
<section id="constant-with-name">
<h3><code class="docutils literal notranslate"><span class="pre">constant-with-name</span></code></h3>
<p>( x name – )</p>
<p>Define a constant with a name.</p>
</section>
<section id="raw-constant-with-name">
<h3><code class="docutils literal notranslate"><span class="pre">raw-constant-with-name</span></code></h3>
<p>( x name – )</p>
<p>Define a raw constant with a name.</p>
</section>
<section id="char">
<h3><code class="docutils literal notranslate"><span class="pre">[char]</span></code></h3>
<p>( “name” – x )</p>
<p>Redefine [CHAR].</p>
</section>
<section id="id58">
<h3><code class="docutils literal notranslate"><span class="pre">char</span></code></h3>
<p>( “name” – x )</p>
<p>Redefine CHAR.</p>
</section>
<section id="begin-record">
<h3><code class="docutils literal notranslate"><span class="pre">begin-record</span></code></h3>
<p>( “name” – token offset )</p>
<p>Begin declaring a record.</p>
</section>
<section id="end-record">
<h3><code class="docutils literal notranslate"><span class="pre">end-record</span></code></h3>
<p>( token offset – )</p>
<p>Finish declaring a record.</p>
</section>
<section id="item">
<h3><code class="docutils literal notranslate"><span class="pre">item:</span></code></h3>
<p>( offset “name” – offset’ )</p>
<p>Create a field in a record.</p>
</section>
<section id="foreign-constant">
<h3><code class="docutils literal notranslate"><span class="pre">foreign-constant</span></code></h3>
<p>( “foreign-name” “new-name” – )</p>
<p>Make a foreign constant.</p>
</section>
<section id="foreign-variable">
<h3><code class="docutils literal notranslate"><span class="pre">foreign-variable</span></code></h3>
<p>( “foreign-name” “new-name” – )</p>
<p>Make a foreign variable.</p>
</section>
<section id="foreign">
<h3><code class="docutils literal notranslate"><span class="pre">foreign</span></code></h3>
<p>( in-count out-count “foreign-name” “new-name” – )</p>
<p>Make a foreign word usable.</p>
</section>
<section id="execute-foreign">
<h3><code class="docutils literal notranslate"><span class="pre">execute-foreign</span></code></h3>
<p>( in-count out-count xt – )</p>
<p>Execute a foreign word.</p>
</section>
<section id="find">
<h3><code class="docutils literal notranslate"><span class="pre">find</span></code></h3>
<p>( seq – word|0 )</p>
<p>Find a word.</p>
</section>
<section id="find-all-dict">
<h3><code class="docutils literal notranslate"><span class="pre">find-all-dict</span></code></h3>
<p>( seq word – word’|0 )</p>
<p>Find a word in a dictionary in all wordlists.</p>
</section>
<section id="flash-latest">
<h3><code class="docutils literal notranslate"><span class="pre">flash-latest</span></code></h3>
<p>( – word )</p>
<p>Get the latest word in flash.</p>
</section>
<section id="ram-latest">
<h3><code class="docutils literal notranslate"><span class="pre">ram-latest</span></code></h3>
<p>( – word )</p>
<p>Get the latest word in RAM.</p>
</section>
<section id="latest">
<h3><code class="docutils literal notranslate"><span class="pre">latest</span></code></h3>
<p>( – word )</p>
<p>Get the latest word.</p>
</section>
<section id="state">
<h3><code class="docutils literal notranslate"><span class="pre">state?</span></code></h3>
<p>( – state? )</p>
<p>Get the compilation state.</p>
</section>
<section id="to">
<h3><code class="docutils literal notranslate"><span class="pre">+to</span></code></h3>
<p>( x “name” – )</p>
<p>Add to a local or a VALUE.</p>
</section>
<section id="constant">
<h3><code class="docutils literal notranslate"><span class="pre">constant</span></code></h3>
<p>( x “name” – )</p>
<p>Define a CONSTANT.</p>
</section>
<section id="id59">
<h3><code class="docutils literal notranslate"><span class="pre">2constant</span></code></h3>
<p>( x0 x1 “name” – )</p>
<p>Define a 2CONSTANT.</p>
</section>
<section id="global">
<h3><code class="docutils literal notranslate"><span class="pre">global</span></code></h3>
<p>( “name” – )</p>
<p>Create a global.</p>
</section>
<section id="bind">
<h3><code class="docutils literal notranslate"><span class="pre">bind</span></code></h3>
<p>( xn … x0 count xt – closure )</p>
<p>Bind a scope to a lambda.</p>
</section>
<section id="pick">
<h3><code class="docutils literal notranslate"><span class="pre">pick</span></code></h3>
<p>( xn … x0 u – x )</p>
<p>Redefine PICK.</p>
</section>
<section id="roll">
<h3><code class="docutils literal notranslate"><span class="pre">roll</span></code></h3>
<p>( xn … x0 u – xn-1 … x0 xn u )</p>
<p>Redefine ROLL.</p>
</section>
<section id="base">
<h3><code class="docutils literal notranslate"><span class="pre">base!</span></code></h3>
<p>( base – )</p>
<p>Set BASE.</p>
</section>
<section id="id60">
<h3><code class="docutils literal notranslate"><span class="pre">base&#64;</span></code></h3>
<p>( – base )</p>
<p>Get BASE.</p>
</section>
<section id="with-base">
<h3><code class="docutils literal notranslate"><span class="pre">with-base</span></code></h3>
<p>( base xt – )</p>
<p>Execute an xt with a BASE.</p>
</section>
<section id="parse-integer">
<h3><code class="docutils literal notranslate"><span class="pre">parse-integer</span></code></h3>
<p>( seq – n success )</p>
<p>Parse an integer.</p>
</section>
<section id="duplicate">
<h3><code class="docutils literal notranslate"><span class="pre">duplicate</span></code></h3>
<p>( seq0 – seq1 )</p>
<p>Duplicate a cell or byte sequence; this converts slices to non-slices and constant byte sequences into non-constant byte sequences.</p>
</section>
<section id="concat">
<h3><code class="docutils literal notranslate"><span class="pre">concat</span></code></h3>
<p>( seq0 seq1 – seq2 )</p>
<p>Concatenate two cell or byte sequences.</p>
</section>
<section id="iter">
<h3><code class="docutils literal notranslate"><span class="pre">iter</span></code></h3>
<p>( seq xt – )</p>
<p>Iterate over a cell sequence.</p>
</section>
<section id="iteri">
<h3><code class="docutils literal notranslate"><span class="pre">iteri</span></code></h3>
<p>( seq xt – )</p>
<p>Iterate over a cell sequence with an index.</p>
</section>
<section id="map">
<h3><code class="docutils literal notranslate"><span class="pre">map</span></code></h3>
<p>( seq xt – seq’ )</p>
<p>Map a cell or byte sequence into a new cell sequence.</p>
</section>
<section id="mapi">
<h3><code class="docutils literal notranslate"><span class="pre">mapi</span></code></h3>
<p>( seq xt – seq’ )</p>
<p>Map a cell or byte sequence into a new cell sequence with an index.</p>
</section>
<section id="id61">
<h3><code class="docutils literal notranslate"><span class="pre">map!</span></code></h3>
<p>( seq xt – )</p>
<p>Map a cell or byte sequence in place.</p>
</section>
<section id="id62">
<h3><code class="docutils literal notranslate"><span class="pre">mapi!</span></code></h3>
<p>( seq xt – )</p>
<p>Map a cell or byte sequence in place with an index.</p>
</section>
<section id="make-bits">
<h3><code class="docutils literal notranslate"><span class="pre">make-bits</span></code></h3>
<p>( len – bits )</p>
<p>Make a zeroed bit sequence.</p>
</section>
<section id="bits-len">
<h3><code class="docutils literal notranslate"><span class="pre">bits&gt;len</span></code></h3>
<p>( bits – len )</p>
<p>Get the length of bits.</p>
</section>
<section id="bit">
<h3><code class="docutils literal notranslate"><span class="pre">bit!</span></code></h3>
<p>( bit index bits – )</p>
<p>Set a bit in a bit sequence.</p>
</section>
<section id="id63">
<h3><code class="docutils literal notranslate"><span class="pre">bit&#64;</span></code></h3>
<p>( index bits – )</p>
<p>Get a bit in a bit sequence.</p>
</section>
<section id="filter">
<h3><code class="docutils literal notranslate"><span class="pre">filter</span></code></h3>
<p>( seq xt – seq’ )</p>
<p>Filter a cell or byte sequence.</p>
</section>
<section id="filteri">
<h3><code class="docutils literal notranslate"><span class="pre">filteri</span></code></h3>
<p>( seq xt – seq’ )</p>
<p>Filter a cell or byte sequence with an index.</p>
</section>
<section id="foldl">
<h3><code class="docutils literal notranslate"><span class="pre">foldl</span></code></h3>
<p>( x seq xt – x’ ) xt: ( x item – x’ )</p>
<p>Fold left over a cell or byte sequence.</p>
</section>
<section id="foldli">
<h3><code class="docutils literal notranslate"><span class="pre">foldli</span></code></h3>
<p>( x seq xt – x’ ) xt: ( x item index – x’ )</p>
<p>Fold left over a cell or byte sequence with an index.</p>
</section>
<section id="foldr">
<h3><code class="docutils literal notranslate"><span class="pre">foldr</span></code></h3>
<p>( x seq xt – x’ ) xt: ( item x – x’ )</p>
<p>Fold right over a cell or byte sequence.</p>
</section>
<section id="foldri">
<h3><code class="docutils literal notranslate"><span class="pre">foldri</span></code></h3>
<p>( x seq xt – x’ ) xt: ( item x index – x’ )</p>
<p>Fold right over a cell or byte sequence with an index.</p>
</section>
<section id="reverse">
<h3><code class="docutils literal notranslate"><span class="pre">reverse</span></code></h3>
<p>( seq – seq’ )</p>
<p>Reverse a sequence producing a new sequence.</p>
</section>
<section id="id64">
<h3><code class="docutils literal notranslate"><span class="pre">reverse!</span></code></h3>
<p>( seq – )</p>
<p>Reverse a sequence in place.</p>
</section>
<section id="zip">
<h3><code class="docutils literal notranslate"><span class="pre">zip</span></code></h3>
<p>( seq0 seq1 – seq2 )</p>
<p>Zip two sequences into a new sequence, using the length of the shorter sequence.</p>
</section>
<section id="zip3">
<h3><code class="docutils literal notranslate"><span class="pre">zip3</span></code></h3>
<p>( seq0 seq1 seq2 – seq3 )</p>
<p>Zip three sequences into a new sequence, using the length of the shorter sequence.</p>
</section>
<section id="id65">
<h3><code class="docutils literal notranslate"><span class="pre">zip!</span></code></h3>
<p>( seq0 seq1 – )</p>
<p>Zip two sequences into the first sequence in-place; note that if the ranges do not match an exception is raised, and the first sequence must be a cell sequence.</p>
</section>
<section id="id66">
<h3><code class="docutils literal notranslate"><span class="pre">zip3!</span></code></h3>
<p>( seq0 seq1 seq2 – )</p>
<p>Zip three sequences into the first sequence in-place; note that if the ranges do not match an exception is raised, and the first sequence must be a cell sequence.</p>
</section>
<section id="sort">
<h3><code class="docutils literal notranslate"><span class="pre">sort!</span></code></h3>
<p>( seq xt – )</p>
<p>Heapsort a cell or byte sequence in place.</p>
</section>
<section id="id67">
<h3><code class="docutils literal notranslate"><span class="pre">sort</span></code></h3>
<p>( seq xt – )</p>
<p>Heapsort a cell or byte sequence, copying it.</p>
</section>
<section id="all">
<h3><code class="docutils literal notranslate"><span class="pre">all</span></code></h3>
<p>( seq xt – all? )</p>
<p>Get whether a predicate applies to all elements of a sequence; note that not all elements will be iterated over if an element returns false, and true will be returned if the sequence is empty.</p>
</section>
<section id="any">
<h3><code class="docutils literal notranslate"><span class="pre">any</span></code></h3>
<p>( seq xt – any? )</p>
<p>Get whether a predicate applies to any element of a sequence; note that not all elements will be iterated over if an element returns true, and false will be returned if the sequence is empty.</p>
</section>
<section id="join">
<h3><code class="docutils literal notranslate"><span class="pre">join</span></code></h3>
<p>( list-seq join-seq – seq’ )</p>
<p>Join a cell sequence of cell or byte sequences.</p>
</section>
<section id="depth">
<h3><code class="docutils literal notranslate"><span class="pre">depth</span></code></h3>
<p>( – depth )</p>
<p>Get the current depth.</p>
</section>
<section id="id68">
<h3><code class="docutils literal notranslate"><span class="pre">#(</span></code></h3>
<p>( – )</p>
<p>Start defining a cell sequence.</p>
</section>
<section id="id69">
<h3><code class="docutils literal notranslate"><span class="pre">#&lt;</span></code></h3>
<p>( – )</p>
<p>Start defining a byte sequence.</p>
</section>
<section id="id70">
<h3><code class="docutils literal notranslate"><span class="pre">)#</span></code></h3>
<p>( xn … x0 – cells )</p>
<p>Finish definining a cell sequence.</p>
</section>
<section id="id71">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;#</span></code></h3>
<p>( cn … c0 – bytes )</p>
<p>Finish defining a byte sequence.</p>
</section>
<section id="id72">
<h3><code class="docutils literal notranslate"><span class="pre">0cells</span></code></h3>
<p>( – cells )</p>
<p>Empty cell sequence.</p>
</section>
<section id="id73">
<h3><code class="docutils literal notranslate"><span class="pre">0bytes</span></code></h3>
<p>( – bytes )</p>
<p>Empty byte sequence.</p>
</section>
</section>
<section id="unsafe-words">
<h2><code class="docutils literal notranslate"><span class="pre">unsafe</span></code> words</h2>
<section id="bytes-addr-len">
<h3><code class="docutils literal notranslate"><span class="pre">bytes&gt;addr-len</span></code></h3>
<p>( bytes – addr len )</p>
<p>Get the starting address and length of a byte sequence or slice. Note that these are not guaranteed to remain constant with any subsequent allocations that may trigger the garbage collector.</p>
</section>
<section id="id74">
<h3><code class="docutils literal notranslate"><span class="pre">&#64;</span></code></h3>
<p>( addr – x )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>.</p>
</section>
<section id="id75">
<h3><code class="docutils literal notranslate"><span class="pre">!</span></code></h3>
<p>( x addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">!</span></code>.</p>
</section>
<section id="id76">
<h3><code class="docutils literal notranslate"><span class="pre">+!</span></code></h3>
<p>( x addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">+!</span></code>.</p>
</section>
<section id="bis">
<h3><code class="docutils literal notranslate"><span class="pre">bis!</span></code></h3>
<p>( x addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">BIS!</span></code>.</p>
</section>
<section id="id77">
<h3><code class="docutils literal notranslate"><span class="pre">bic!</span></code></h3>
<p>( x addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">BIC!</span></code>.</p>
</section>
<section id="id78">
<h3><code class="docutils literal notranslate"><span class="pre">xor!</span></code></h3>
<p>( x addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">XOR!</span></code>.</p>
</section>
<section id="id79">
<h3><code class="docutils literal notranslate"><span class="pre">h&#64;</span></code></h3>
<p>( addr – h )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">H&#64;</span></code>.</p>
</section>
<section id="id80">
<h3><code class="docutils literal notranslate"><span class="pre">h!</span></code></h3>
<p>( h addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">H!</span></code>.</p>
</section>
<section id="id81">
<h3><code class="docutils literal notranslate"><span class="pre">h+!</span></code></h3>
<p>( h addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">H+!</span></code>.</p>
</section>
<section id="hbis">
<h3><code class="docutils literal notranslate"><span class="pre">hbis!</span></code></h3>
<p>( x addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">HBIS!</span></code>.</p>
</section>
<section id="hbic">
<h3><code class="docutils literal notranslate"><span class="pre">hbic!</span></code></h3>
<p>( x addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">HBIC!</span></code>.</p>
</section>
<section id="hxor">
<h3><code class="docutils literal notranslate"><span class="pre">hxor!</span></code></h3>
<p>( x addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">HXOR!</span></code>.</p>
</section>
<section id="id82">
<h3><code class="docutils literal notranslate"><span class="pre">c&#64;</span></code></h3>
<p>( addr – c )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">C&#64;</span></code>.</p>
</section>
<section id="id83">
<h3><code class="docutils literal notranslate"><span class="pre">c!</span></code></h3>
<p>( c addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">C!</span></code>.</p>
</section>
<section id="id84">
<h3><code class="docutils literal notranslate"><span class="pre">c+!</span></code></h3>
<p>( c addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">C+!</span></code>.</p>
</section>
<section id="cbis">
<h3><code class="docutils literal notranslate"><span class="pre">cbis!</span></code></h3>
<p>( x addr – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">CBIS!</span></code>.</p>
</section>
<section id="fill">
<h3><code class="docutils literal notranslate"><span class="pre">fill</span></code></h3>
<p>( addr bytes val – )</p>
<p>Redefine <code class="docutils literal notranslate"><span class="pre">FILL</span></code>.</p>
</section>
<section id="id85">
<h3><code class="docutils literal notranslate"><span class="pre">&gt;integral</span></code></h3>
<p>( x – value )</p>
<p>Cast a value to an integer.</p>
</section>
<section id="id86">
<h3><code class="docutils literal notranslate"><span class="pre">integral&gt;</span></code></h3>
<p>( value – x )</p>
<p>Cast a value from an integer.</p>
</section>
<section id="id87">
<h3><code class="docutils literal notranslate"><span class="pre">2&gt;integral</span></code></h3>
<p>( x0 x1 – value0 value1 )</p>
<p>Cast two values to integers.</p>
</section>
<section id="id88">
<h3><code class="docutils literal notranslate"><span class="pre">2integral&gt;</span></code></h3>
<p>( value0 value1 – x0 x1 )</p>
<p>Cast two values from integers.</p>
</section>
<section id="xt-integral">
<h3><code class="docutils literal notranslate"><span class="pre">xt&gt;integral</span></code></h3>
<p>( xt – value )</p>
<p>Convert an xt to an integral.</p>
</section>
<section id="integral-xt">
<h3><code class="docutils literal notranslate"><span class="pre">integral&gt;xt</span></code></h3>
<p>( value – xt )</p>
<p>Convert an integral to an xt.</p>
</section>
<section id="here">
<h3><code class="docutils literal notranslate"><span class="pre">here</span></code></h3>
<p>( – x )</p>
<p>Get the HERE pointer.</p>
</section>
<section id="allot">
<h3><code class="docutils literal notranslate"><span class="pre">allot</span></code></h3>
<p>( x – )</p>
<p>ALLOT space.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>